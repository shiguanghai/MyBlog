(window.webpackJsonp=window.webpackJsonp||[]).push([[35],{525:function(a,s,t){"use strict";t.r(s);var n=t(1),r=Object(n.a)({},(function(){var a=this,s=a.$createElement,t=a._self._c||s;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h2",{attrs:{id:"作用域是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#作用域是什么"}},[a._v("#")]),a._v(" 作用域是什么")]),a._v(" "),t("p",[a._v("几乎所有编程语言最基本的功能之一，就是"),t("strong",[a._v("能够储存变量当中的值， 并且能在之后对这个值进行访问或修改")]),a._v("。")]),a._v(" "),t("p",[a._v("但是这些变量住在哪里？换句话说，它们储存在哪里？最重要的是，程序需要时如何找到它们？\n这些问题说明需要一套设计良好的规则来存储变量， 并且之后可以方便地找到这些变量。这套规则被称为"),t("strong",[a._v("作用域")]),a._v("。")]),a._v(" "),t("h3",{attrs:{id:"编译原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#编译原理"}},[a._v("#")]),a._v(" 编译原理")]),a._v(" "),t("p",[a._v("尽管通常将JavaScript归类为“ 动态”或“ 解释执行”语言， 但事实上它是一门编译语言。\nJavaScript 与传统的编译语言不同， 它不是提前编译的， 编译结果也不能在分布式系统中进行移植。")]),a._v(" "),t("p",[a._v("在传统编译语言的流程中， 程序中的一段源代码在执行之前会经历三个步骤， 统称为“ 编译” ：")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("分词/词法分析（Tokenizing/Lexing）")]),a._v(" "),t("ul",[t("li",[a._v("这个过程会将由字符组成的字符串分解成（ 对编程语言来说）有意义的代码块， 这些代码块被称为词法单元（token）")]),a._v(" "),t("li",[a._v("例如 var a  =  2; => var、a、=、2、;")]),a._v(" "),t("li",[a._v("如果词法单元生成器在判断a是一个独立的词法单元还是其他词法单元的一部分时， 调用的是有状态的解析规则， 那么这个过程就被称为词法分析。")])])]),a._v(" "),t("li",[t("p",[a._v("解析/语法分析（Parsing）")]),a._v(" "),t("ul",[t("li",[a._v("这个过程是将词法单元流（ 数组）转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树。这个树被称为“抽象语法树”（Abstract Syntax Tree，AST）。")]),a._v(" "),t("li",[a._v("例如 var a  =  2; => 顶级节点 VariableDeclaration -> 子节点 Identifier(值为a) -> 子节点 AssignmentExpression -> 子节点 NumericLiteral(值为2)")])])]),a._v(" "),t("li",[t("p",[a._v("代码生成")]),a._v(" "),t("ul",[t("li",[a._v("将AST转换为可执行代码的过程称被称为代码生成。")]),a._v(" "),t("li",[a._v("例如将 var a  =  2; => 其AST转化为一组机器指令，用来创建一个叫作a的变量（包括分配内存等），并将一个值储存在a中。")])])])]),a._v(" "),t("p",[t("strong",[a._v("相比这些，JavaScript引擎要复杂的多")])]),a._v(" "),t("ul",[t("li",[a._v("不会有大量的时间用来进行优化（编译过程不是发生在构建之前的）")]),a._v(" "),t("li",[a._v("大部分情况下编译发生在代码执行前的几微秒（甚至更短）的时间内")]),a._v(" "),t("li",[a._v("在执行前都要进行编译（通常就在执行前）")])]),a._v(" "),t("h3",{attrs:{id:"理解作用域"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#理解作用域"}},[a._v("#")]),a._v(" 理解作用域")]),a._v(" "),t("ul",[t("li",[a._v("引擎 负责整个JavaScript程序的编译及执行过程")]),a._v(" "),t("li",[a._v("编译器 负责语法分析及代码生成等")]),a._v(" "),t("li",[a._v("作用域 负责收集并维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限")])]),a._v(" "),t("p",[a._v("我们继续拿 var a = 2; 举例子：编译器首先会将这段程序分解成词法单元， 然后将词法单元解析成一个树结构。 但是当编译器开始进行代码生成时，它对这段程序的处理方式会和预期的有所不同。")]),a._v(" "),t("p",[a._v("通常我们会认为其处理过程为“为一个变量分配内存，将其命名为a，然后将值2保存进这个变量。”然而，这并不完全正确。")]),a._v(" "),t("p",[a._v("事实上编译器会进行如下处理：")]),a._v(" "),t("ol",[t("li",[a._v("遇到var a，编译器会询问作用域是否已经有一个该名称的变量存在于同一个作用域的集合中。如果是，编译器会忽略该声明，继续进行编译；否则它会要求作用域在当前作用域的集合中声明一个新的变量，并命名为a。")]),a._v(" "),t("li",[a._v("接下来编译器会为引擎生成运行时所需的代码，这些代码被用来处理 a=2 这个赋值操作。引擎运行时会首先询问作用域，在当前的作用域集合中是否存在一个叫作a的变量。如果是，引擎就会使用这个变量；如果否，引擎会继续查找该变量。")]),a._v(" "),t("li",[a._v("如果引擎最终找到了a变量，就会将2赋值给它。否则引擎就会示意并抛出一个异常。")])]),a._v(" "),t("p",[a._v("查找的过程由作用域进行协助，但是引擎执行怎样的查找，会影响最终的查找结果。")]),a._v(" "),t("p",[a._v("我们先引入两个概念："),t("strong",[a._v("LHS查询")]),a._v("（赋值操作的目标是谁） 和 "),t("strong",[a._v("RHS查询")]),a._v("（谁是赋值操作的源头）")]),a._v(" "),t("p",[a._v("在我们的例子中，引擎会为变量a进行LHS查询，LHS查询试图找到变量的容器本身，从而可以对其赋值。我们并不关心当前的值是什么，只是想要为 =2 这个赋值操作找到一个目标。\n相比而言，我们再来考虑 console.log(a) 这段代码。其中对a的引用是一个RHS引用，因为这里a并没有赋予任何值。相应地，需要查找并取得a的值，这样才能将值传递给console.log(..)。")]),a._v(" "),t("p",[a._v("为了更好地理解，我们再来看下面这段代码：")]),a._v(" "),t("div",{staticClass:"language-js line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("function")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("foo")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token parameter"}},[a._v("a")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("  \n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("    \n  console"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("log")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("a"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 2")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("foo")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("2")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br"),t("span",{staticClass:"line-number"},[a._v("5")]),t("br")])]),t("p",[a._v("最后一行foo(..)函数的调用需要对foo进行"),t("strong",[a._v("RHS引用")]),a._v("，意味着“去找到foo的值，并把它给我”。并且(..)意味着foo的值需要被执行，因此它最好真的是一个函数类型的值！\n这里还有一个容易被忽略却非常重要的细节。\n代码中隐式的a＝2操作可能很容易被你忽略掉。这个操作发生在2被当作参数传递给foo(..)函数时，2会被分配给参数a。为了给参数a（隐式地）分配值，需要进行一次"),t("strong",[a._v("LHS查询")]),a._v("。\n这里还有对a进行的"),t("strong",[a._v("RHS引用")]),a._v("，并且将得到的值传给了console.log(..)。console.log(..)本身也需要一个引用才能执行，因此会对console对象进行"),t("strong",[a._v("RHS查询")]),a._v("，并且检查得到的值中是否有一个叫作log的方法。")]),a._v(" "),t("h3",{attrs:{id:"作用域嵌套"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#作用域嵌套"}},[a._v("#")]),a._v(" 作用域嵌套")]),a._v(" "),t("p",[a._v("我们说过，作用域是根据名称查找变量的一套规则。实际情况中，通常需要同时顾及几个作用域。")]),a._v(" "),t("p",[a._v("当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。因此，在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量，或抵达最外层的作用域（也就是全局作用域）为止。")]),a._v(" "),t("div",{staticClass:"language-js line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("function")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("foo")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token parameter"}},[a._v("a")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n  console"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("log")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("a"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("+")]),a._v("b"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("var")]),a._v(" b "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("2")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n\n"),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("foo")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("2")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 4")]),a._v("\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br"),t("span",{staticClass:"line-number"},[a._v("5")]),t("br"),t("span",{staticClass:"line-number"},[a._v("6")]),t("br"),t("span",{staticClass:"line-number"},[a._v("7")]),t("br")])]),t("p",[a._v("对b进行的RHS引用无法在函数foo内部完成，但可以在上一级作用域（在这个例子中就是全局作用域）中完成。")]),a._v(" "),t("p",[a._v("遍历嵌套作用域链的规则很简单：引擎从当前的执行作用域开始查找变量，如果找不到，就向上一级继续查找。当抵达最外层的全局作用域时，无论找到还是没找到，查找过程都会停止。")]),a._v(" "),t("h3",{attrs:{id:"异常"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#异常"}},[a._v("#")]),a._v(" 异常")]),a._v(" "),t("p",[a._v("为什么区分LHS和RHS是一件重要的事情？")]),a._v(" "),t("p",[a._v("因为在变量还没有声明（在任何作用域中都无法找到该变量）的情况下，这两种查询的行为是不一样的。")]),a._v(" "),t("div",{staticClass:"language-js line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("function")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("foo")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token parameter"}},[a._v("a")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n  console"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("log")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("a"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("+")]),a._v("b"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n  b "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" a"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n\n"),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("foo")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("2")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br"),t("span",{staticClass:"line-number"},[a._v("5")]),t("br"),t("span",{staticClass:"line-number"},[a._v("6")]),t("br")])]),t("p",[a._v("第一次对b进行RHS查询时是无法找到该变量的。也就是说，这是一个“未声明”的变量，因为在任何相关的作用域中都无法找到它。")]),a._v(" "),t("p",[a._v("如果RHS查询在所有嵌套的作用域中遍寻不到所需的变量，引擎就会抛出ReferenceError异常。值得注意的是，ReferenceError是非常重要的异常类型。")]),a._v(" "),t("p",[a._v("相较之下，当引擎执行LHS查询时，如果在顶层（全局作用域）中也无法找到目标变量，全局作用域中就会创建一个具有该名称的变量，并将其返还给引擎，前提是程序运行在非“严格模式”下。")]),a._v(" "),t("p",[a._v("ES5中引入了“严格模式”。同正常模式，或者说宽松/懒惰模式相比，严格模式在行为上有很多不同。其中一个不同的行为是"),t("strong",[a._v("严格模式禁止自动或隐式地创建全局变量")]),a._v("。因此，在严格模式中LHS查询失败时，并不会创建并返回一个全局变量，引擎会抛出同RHS查询失败时类似的ReferenceError异常。")]),a._v(" "),t("p",[a._v("接下来，如果RHS查询找到了一个变量，但是你尝试对这个变量的值进行不合理的操作，比如试图对一个非函数类型的值进行函数调用，或着引用null或undefined类型的值中的属性，那么引擎会抛出另外一种类型的异常，叫作TypeError。")]),a._v(" "),t("p",[a._v("ReferenceError同作用域判别失败相关，而TypeError则代表作用域判别成功了，但是对结果的操作是非法或不合理的。")]),a._v(" "),t("h3",{attrs:{id:"小结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#小结"}},[a._v("#")]),a._v(" 小结")]),a._v(" "),t("p",[a._v("作用域是一套规则，用于确定在何处以及如何查找变量（标识符）。如果查找的目的是对变量进行赋值，那么就会使用 LHS 查询；如果目的是获取变量的值，就会使用 RHS 查询。")]),a._v(" "),t("p",[a._v("赋值操作符会导致 LHS 查询。'＝'操作符或调用函数时传入参数的操作都会导致关联作用域的赋值操作。")]),a._v(" "),t("p",[a._v("JavaScript 引擎首先会在代码执行前对其进行编译，在这个过程中，像 var a = 2 这样的声明会被分解成两个独立的步骤：")]),a._v(" "),t("ol",[t("li",[a._v("首先，var a 在其作用域中声明新变量。这会在最开始的阶段，也就是代码执行前进行。")]),a._v(" "),t("li",[a._v("接下来，a = 2 会查询（LHS 查询）变量 a 并对其进行赋值。\nLHS 和 RHS 查询都会在当前执行作用域中开始，如果有需要（也就是说它们没有找到所需的标识符），就会向上级作用域继续查找目标标识符，这样每次上升一级作用域，最后抵达全局作用域，无论找到或没找到都将停止。")])]),a._v(" "),t("p",[a._v("不成功的 RHS 引用会导致抛出 ReferenceError 异常。不成功的 LHS 引用会导致自动隐式地创建一个全局变量（非严格模式下），该变量使用 LHS 引用的目标作为标识符，或者抛出 ReferenceError 异常（严格模式下）。")])])}),[],!1,null,null,null);s.default=r.exports}}]);