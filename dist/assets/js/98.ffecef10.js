(window.webpackJsonp=window.webpackJsonp||[]).push([[98],{597:function(e,t,v){"use strict";v.r(t);var a=v(2),_=Object(a.a)({},(function(){var e=this,t=e.$createElement,v=e._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h2",{attrs:{id:"说一下在webpack中的loader和plugin的不同"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#说一下在webpack中的loader和plugin的不同"}},[e._v("#")]),e._v(" 说一下在webpack中的loader和plugin的不同")]),e._v(" "),v("h3",{attrs:{id:"解题思路"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#解题思路"}},[e._v("#")]),e._v(" 解题思路")]),e._v(" "),v("p",[v("strong",[e._v("不同的作用")]),e._v("：")]),e._v(" "),v("ul",[v("li",[v("strong",[e._v("Loader")]),e._v('直译为"加载器"。Webpack将一切文件视为模块，但是webpack原生是只能解析js文件，如果想将其他文件也打包的话，就会用到'),v("code",[e._v("loader")]),e._v("。 所以Loader的作用是让webpack拥有了加载和解析 "),v("em",[e._v("非JavaScript文件")]),e._v(" 的能力。")]),e._v(" "),v("li",[v("strong",[e._v("Plugin")]),e._v('直译为"插件"。Plugin可以扩展webpack的功能，让webpack具有更多的灵活性。 在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。')])]),e._v(" "),v("p",[v("strong",[e._v("不同的用法")]),e._v("：")]),e._v(" "),v("ul",[v("li",[v("strong",[e._v("Loader")]),e._v("在"),v("code",[e._v("module.rules")]),e._v("中配置，也就是说他作为模块的解析规则而存在。 类型为数组，每一项都是一个"),v("code",[e._v("Object")]),e._v("，里面描述了对于什么类型的文件（"),v("code",[e._v("test")]),e._v("），使用什么加载("),v("code",[e._v("loader")]),e._v(")和使用的参数（"),v("code",[e._v("options")]),e._v("）")]),e._v(" "),v("li",[v("strong",[e._v("Plugin")]),e._v("在"),v("code",[e._v("plugins")]),e._v("中单独配置。 类型为数组，每一项是一个"),v("code",[e._v("plugin")]),e._v("的实例，参数都通过构造函数传入。")])])])}),[],!1,null,null,null);t.default=_.exports}}]);