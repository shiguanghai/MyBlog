(window.webpackJsonp=window.webpackJsonp||[]).push([[67],{558:function(_,v,e){"use strict";e.r(v);var o=e(1),c=Object(o.a)({},(function(){var _=this,v=_.$createElement,e=_._self._c||v;return e("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[e("h2",{attrs:{id:"【简答题】一、请简述-vue-首次渲染的过程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#【简答题】一、请简述-vue-首次渲染的过程"}},[_._v("#")]),_._v(" 【简答题】一、请简述 Vue 首次渲染的过程")]),_._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdnimg.cn/20201205195820451.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1MTQ5MjU2,size_16,color_FFFFFF,t_70#pic_center",alt:"在这里插入图片描述"}})]),_._v(" "),e("ul",[e("li",[_._v("对 Vue 构造函数进行初始化，挂载实例成员和静态成员")]),_._v(" "),e("li",[_._v("初始化结束，调用Vue的构造函数 "),e("code",[_._v("new Vue()")])]),_._v(" "),e("li",[_._v("在构造函数中，调用 "),e("code",[_._v("_init()")]),_._v("，相当于整个Vue的入口")]),_._v(" "),e("li",[_._v("在 "),e("code",[_._v("_init")]),_._v(" 方法中最终调用了入口文件"),e("code",[_._v("entry-runtime-with-compiler.js")]),_._v("的 "),e("code",[_._v("$mount()")]),_._v("，把 "),e("code",[_._v("template")]),_._v(" 模板编译成 "),e("code",[_._v("render")]),_._v(" 函数\n"),e("ul",[e("li",[_._v("判断是否传入了 "),e("code",[_._v("render")]),_._v(" 选项，如果没有传入，会去获取 "),e("code",[_._v("templiate")]),_._v(" 选项，如果 "),e("code",[_._v("template")]),_._v(" 中也没有，会把 "),e("code",[_._v("el")]),_._v(" 中的内容作为模板")]),_._v(" "),e("li",[_._v("通过 "),e("code",[_._v("compileToFunctions()")]),_._v(" 把模板编译成 "),e("code",[_._v("render")]),_._v(" 函数")]),_._v(" "),e("li",[_._v("把 "),e("code",[_._v("render")]),_._v(" 函数存到 "),e("code",[_._v("options.render")])])])]),_._v(" "),e("li",[_._v("调用 "),e("code",[_._v("platforms/web/runtime/index.js")]),_._v(" 中的 "),e("code",[_._v("$mount()")]),_._v(" "),e("ul",[e("li",[_._v("如果是运行时版本，重新获取 "),e("code",[_._v("el")]),_._v("（运行时版本不会走入口文件获取 "),e("code",[_._v("el")]),_._v(" ）")])])]),_._v(" "),e("li",[_._v("调用 "),e("code",[_._v("core/instance/lifecycle.js")]),_._v(" 文件中定义的 "),e("code",[_._v("mountComponent(this, el)")]),_._v(" "),e("ul",[e("li",[_._v("如果是开发环境，判断是否有 "),e("code",[_._v("render")]),_._v(" 选项，如果传入模板且没有设置 "),e("code",[_._v("render")]),_._v(" 选项则发送警告（运行时版本，没有传入 "),e("code",[_._v("render")]),_._v("，传入模板会告诉我们运行时版本不支持编译器）")]),_._v(" "),e("li",[_._v("触发生命周期的 "),e("code",[_._v("beforeMount")]),_._v(" 钩子函数（开始挂载之前）")]),_._v(" "),e("li",[_._v("定义 "),e("code",[_._v("updateComponent()")]),_._v(" "),e("ul",[e("li",[_._v("调用 "),e("code",[_._v("vm._render")]),_._v(" 和 "),e("code",[_._v("vm._update")])]),_._v(" "),e("li",[e("code",[_._v("vm._render")]),_._v(" 的作用是生成虚拟DOM（用户传入的或编译生成的 "),e("code",[_._v("render")]),_._v("）")]),_._v(" "),e("li",[e("code",[_._v("vm._update")]),_._v(" 的作用是将虚拟DOM转换成真实DOM，并且挂载到页面上（调用 "),e("code",[_._v("__patch__")]),_._v(" 方法，记录 "),e("code",[_._v("vm.$el")]),_._v("）")])])]),_._v(" "),e("li",[_._v("创建 "),e("code",[_._v("Watcher")]),_._v(" 实例\n"),e("ul",[e("li",[_._v("传递了 "),e("code",[_._v("updateComponent")]),_._v(" 这个函数，最终在 "),e("code",[_._v("Watcher")]),_._v(" 内部调用")]),_._v(" "),e("li",[_._v("调用 "),e("code",[_._v("get()")]),_._v(" 方法，"),e("code",[_._v("get()")]),_._v(" 方法中调用 "),e("code",[_._v("updaraComponent()")])])])]),_._v(" "),e("li",[_._v("触发生命周期的 "),e("code",[_._v("mounted")]),_._v(" 钩子函数（挂载结束）")]),_._v(" "),e("li",[_._v("返回Vue实例 "),e("code",[_._v("return vm")])])])])]),_._v(" "),e("h2",{attrs:{id:"【简答题】二、请简述-vue-响应式原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#【简答题】二、请简述-vue-响应式原理"}},[_._v("#")]),_._v(" 【简答题】二、请简述 Vue 响应式原理")]),_._v(" "),e("ul",[e("li",[_._v("Vue的响应式是从Vue的实例"),e("code",[_._v("init()")]),_._v("方法中开始的")])]),_._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdnimg.cn/20201213142853671.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1MTQ5MjU2,size_16,color_FFFFFF,t_70",alt:"在这里插入图片描述"}})]),_._v(" "),e("ul",[e("li",[_._v("在"),e("code",[_._v("init()")]),_._v("方法中先调用"),e("code",[_._v("initState()")]),_._v("初始化Vue实例的状态，在"),e("code",[_._v("initState")]),_._v("方法中调用了"),e("code",[_._v("initData()")]),_._v("，"),e("code",[_._v("initData()")]),_._v("是把data属性注入到Vue实例上，并且调用"),e("code",[_._v("observe(data)")]),_._v("将"),e("code",[_._v("data")]),_._v("对象转化成响应式的对象")]),_._v(" "),e("li",[e("code",[_._v("observe")]),_._v("是响应式的入口\n"),e("ul",[e("li",[_._v("在"),e("code",[_._v("observe(value)")]),_._v("中，首先判断传入的参数"),e("code",[_._v("value")]),_._v("是否是对象，如果不是对象直接返回")]),_._v(" "),e("li",[_._v("再判断"),e("code",[_._v("value")]),_._v("对象是否有"),e("code",[_._v("__ob__")]),_._v("这个属性，如果有说明做过了响应式处理，则直接返回")]),_._v(" "),e("li",[_._v("如果没有，创建"),e("code",[_._v("observer")]),_._v("对象")]),_._v(" "),e("li",[_._v("返回"),e("code",[_._v("observer")]),_._v("对象")])])])]),_._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdnimg.cn/20201213142313121.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1MTQ5MjU2,size_16,color_FFFFFF,t_70",alt:"在这里插入图片描述"}})]),_._v(" "),e("ul",[e("li",[_._v("在创建"),e("code",[_._v("observer")]),_._v("对象时，给当前的"),e("code",[_._v("value")]),_._v("对象定义不可枚举的"),e("code",[_._v("__ob__")]),_._v("属性，记录当前的"),e("code",[_._v("observer")]),_._v("对象，然后再进行数组的响应式处理和对象的响应式处理\n"),e("ul",[e("li",[_._v("数组的响应式处理，就是设置数组的几个特殊的方法，"),e("code",[_._v("push")]),_._v("、"),e("code",[_._v("pop")]),_._v("、"),e("code",[_._v("sort")]),_._v("等，这些方法会改变原数组，所以这些方法被调用的时候需要发送通知\n"),e("ul",[e("li",[_._v("找到数组对象中的"),e("code",[_._v("__ob__")]),_._v("对象中的"),e("code",[_._v("dep")]),_._v(",调用"),e("code",[_._v("dep")]),_._v("的"),e("code",[_._v("notify()")]),_._v("方法")]),_._v(" "),e("li",[_._v("再遍历数组中每一个成员，对每个成员调用"),e("code",[_._v("observe()")]),_._v("，如果这个成员是对象的话，也会转换成响应式对象")])])]),_._v(" "),e("li",[_._v("对象的响应式处理，就是调用"),e("code",[_._v("walk")]),_._v("方法，"),e("code",[_._v("walk")]),_._v("方法就是遍历对象的每一个属性，对每个属性调用"),e("code",[_._v("defineReactive")]),_._v("方法")])])]),_._v(" "),e("li",[e("code",[_._v("defineReactive")]),_._v("会为每一个属性创建对应的"),e("code",[_._v("dep")]),_._v("对象，让"),e("code",[_._v("dep")]),_._v("去收集依赖，如果当前属性的值是对象，会调用"),e("code",[_._v("observe")]),_._v("，"),e("code",[_._v("defineReactive")]),_._v("中最核心的方法是"),e("code",[_._v("getter")]),_._v(" 和 "),e("code",[_._v("setter")]),_._v(" "),e("ul",[e("li",[e("code",[_._v("getter")]),_._v(" 的作用是收集依赖，收集依赖时，为每一个属性收集依赖，如果这个属性的值是对象，那也要为子对象收集依赖，最后返回属性的值")]),_._v(" "),e("li",[_._v("在"),e("code",[_._v("setter")]),_._v(" 中，先保存新值，如果新值是对象，也要调用 "),e("code",[_._v("observe")]),_._v(" ，把新设置的对象也转换成响应式的对象，然后派发更新（发送通知），调用"),e("code",[_._v("dep.notify()")])])])])]),_._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdnimg.cn/20201213143030628.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1MTQ5MjU2,size_16,color_FFFFFF,t_70",alt:"在这里插入图片描述"}})]),_._v(" "),e("ul",[e("li",[_._v("收集依赖时\n"),e("ul",[e("li",[_._v("在"),e("code",[_._v("watcher")]),_._v("对象的"),e("code",[_._v("get")]),_._v("方法中调用"),e("code",[_._v("pushTarget")]),_._v(", 记录"),e("code",[_._v("Dep.target")]),_._v("属性")]),_._v(" "),e("li",[_._v("访问"),e("code",[_._v("data")]),_._v("中的成员的时候收集依赖，"),e("code",[_._v("defineReactive")]),_._v("的"),e("code",[_._v("getter")]),_._v("中收集依赖")]),_._v(" "),e("li",[_._v("把属性对应的 "),e("code",[_._v("watcher")]),_._v(" 对象添加到"),e("code",[_._v("dep")]),_._v("的"),e("code",[_._v("subs")]),_._v("数组中，也就是为属性收集依赖")]),_._v(" "),e("li",[_._v("如果属性的值也是对象，给"),e("code",[_._v("childOb")]),_._v("收集依赖，目的是子对象添加和删除成员时发送通知")])])])]),_._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdnimg.cn/20201213142730966.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1MTQ5MjU2,size_16,color_FFFFFF,t_70",alt:"在这里插入图片描述"}})]),_._v(" "),e("ul",[e("li",[_._v("在数据发生变化的时候\n"),e("ul",[e("li",[_._v("调用"),e("code",[_._v("dep.notify()")]),_._v("发送通知，"),e("code",[_._v("dep.notify()")]),_._v("会调用"),e("code",[_._v("watcher")]),_._v("对象的"),e("code",[_._v("update()")]),_._v("方法")]),_._v(" "),e("li",[e("code",[_._v("update()")]),_._v("中的调用"),e("code",[_._v("queueWatcher()")]),_._v("，会去判断"),e("code",[_._v("watcher")]),_._v("是否被处理，如果这个"),e("code",[_._v("watcher")]),_._v("对象没有被处理的话，添加到"),e("code",[_._v("queue")]),_._v("队列中，并调用"),e("code",[_._v("flushScheduleQueue()")]),_._v(" "),e("ul",[e("li",[_._v("在"),e("code",[_._v("flushScheduleQueue()")]),_._v("中触发"),e("code",[_._v("beforeUpdate")]),_._v("钩子函数")]),_._v(" "),e("li",[_._v("调用"),e("code",[_._v("watcher.run()")]),_._v(" : "),e("code",[_._v("run()--\x3eget() --\x3e getter() --\x3e updateComponent()")])]),_._v(" "),e("li",[_._v("然后清空上一次的依赖")]),_._v(" "),e("li",[_._v("触发"),e("code",[_._v("actived")]),_._v("的钩子函数")]),_._v(" "),e("li",[_._v("触发"),e("code",[_._v("updated")]),_._v("钩子函数")])])])])])]),_._v(" "),e("h2",{attrs:{id:"【简答题】三、请简述虚拟-dom-中-key-的作用和好处"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#【简答题】三、请简述虚拟-dom-中-key-的作用和好处"}},[_._v("#")]),_._v(" 【简答题】三、请简述虚拟 DOM 中 Key 的作用和好处")]),_._v(" "),e("p",[e("strong",[_._v("作用")]),_._v("：追踪列表中哪些元素被添加、被修改、被移除的辅助标志。可以快速对比两个虚拟DOM对象，找到虚拟DOM对象被修改的元素，然后仅仅替换掉被修改的元素，然后再生成新的真实DOM")]),_._v(" "),e("blockquote",[e("p",[_._v("在交叉对比的时候，当新节点跟旧节点头尾交叉对比没有结果的时候，会根据新节点的 key 去对比旧节点数组中的 key，从而找到相应旧节点（这里对应的是一个 key => index 的 map 映射）。如果没找到就认为是一个新增节点。而如果没有 key，那么就会采用一种遍历查找的方式去找到对应的旧节点。一种是一个 map 映射，另一种是遍历查找。相比而言。map 映射的速度更快。")])]),_._v(" "),e("p",[e("strong",[_._v("好处")]),_._v("：可以优化 DOM 的操作，减少Diff算法和渲染所需要的时间，提升性能。")]),_._v(" "),e("h2",{attrs:{id:"【简答题】四、请简述-vue-中模板编译的过程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#【简答题】四、请简述-vue-中模板编译的过程"}},[_._v("#")]),_._v(" 【简答题】四、请简述 Vue 中模板编译的过程")]),_._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdnimg.cn/20201218234256724.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1MTQ5MjU2,size_16,color_FFFFFF,t_70",alt:"在这里插入图片描述"}})]),_._v(" "),e("ul",[e("li",[_._v("模版编译入口函数"),e("code",[_._v("compileToFunctions")]),_._v(" "),e("ul",[e("li",[_._v("内部首先从缓存加载编译好的"),e("code",[_._v("render")]),_._v("函数")]),_._v(" "),e("li",[_._v("如果缓存中没有，调用"),e("code",[_._v("compile")]),_._v("开始编译")])])]),_._v(" "),e("li",[_._v("在 "),e("code",[_._v("compile")]),_._v(" 函数中\n"),e("ul",[e("li",[_._v("首先合并选项"),e("code",[_._v("options")])]),_._v(" "),e("li",[_._v("调用 "),e("code",[_._v("baseCompile")]),_._v(" 编译模版")])])]),_._v(" "),e("li",[e("code",[_._v("compile")]),_._v("的核心是合并选项"),e("code",[_._v("options")]),_._v("， 真正处理是在"),e("code",[_._v("basCompile")]),_._v("中完成的，把模版和合并好的选项传递给"),e("code",[_._v("baseCompile")]),_._v(", 这里面完成了模版编译的核心三件事情\n"),e("ul",[e("li",[e("code",[_._v("parse()")]),_._v(" "),e("ul",[e("li",[_._v("把模版字符串转化为AST 对象，也就是抽象语法树")])])]),_._v(" "),e("li",[e("code",[_._v("optimize()")]),_._v(" "),e("ul",[e("li",[_._v("对抽象语法树进行优化，标记静态语法树中的所以静态根节点")]),_._v(" "),e("li",[_._v("检测到静态子树，设置为静态，不需要在每次重新渲染的时候重新生成节点")]),_._v(" "),e("li",[e("code",[_._v("patch")]),_._v("的过程中会跳过静态根节点")])])]),_._v(" "),e("li",[e("code",[_._v("generator()")]),_._v(" "),e("ul",[e("li",[_._v("把优化过的"),e("code",[_._v("AST")]),_._v("对象，转化为字符串形式的代码")])])])])]),_._v(" "),e("li",[_._v("执行完成之后，会回到入口函数"),e("code",[_._v("complieToFunctions")]),_._v(" "),e("ul",[e("li",[e("code",[_._v("compileToFunction")]),_._v("会继续把字符串代码转化为函数")]),_._v(" "),e("li",[_._v("调用createFunction")]),_._v(" "),e("li",[_._v("当 "),e("code",[_._v("render")]),_._v(" 和 "),e("code",[_._v("staticRenderFns")]),_._v("初始化完毕，最终会挂在到"),e("code",[_._v("Vue")]),_._v("实例的"),e("code",[_._v("options")]),_._v("对应的属性中")])])])])])}),[],!1,null,null,null);v.default=c.exports}}]);