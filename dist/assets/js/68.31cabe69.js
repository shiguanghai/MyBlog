(window.webpackJsonp=window.webpackJsonp||[]).push([[68],{560:function(t,s,v){"use strict";v.r(s);var _=v(2),r=Object(_.a)({},(function(){var t=this,s=t.$createElement,v=t._self._c||s;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h2",{attrs:{id:"详述虚拟dom中的diff算法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#详述虚拟dom中的diff算法"}},[t._v("#")]),t._v(" 详述虚拟DOM中的diff算法")]),t._v(" "),v("h3",{attrs:{id:"解题思路"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#解题思路"}},[t._v("#")]),t._v(" 解题思路：")]),t._v(" "),v("ol",[v("li",[v("p",[v("strong",[t._v("首先要先讲一下虚拟DOM是如何实现的")])]),t._v(" "),v("p",[v("strong",[t._v("虚拟DOM是通过js语法来在内存中维护一个通过数据解构描述出来的一个模拟DOM树，当数据发生改变的时候，会先对虚拟DOM进行模拟修改，然后在通过新的虚拟DOM树与旧的虚拟DOM树来对比，而这个对比就是通过diff算法来进行的")])]),t._v(" "),v("p",[v("strong",[t._v("虚拟DOM最大的意义不在于性能的提升（JavaScript对象比DOM对象性能高），而在于抽象了DOM的具体实现（对DOM进行了一层抽象）")])])]),t._v(" "),v("li",[v("p",[t._v("接着，来看一下diff算法是如何进行比对的")]),t._v(" "),v("p",[t._v("正常的diff算法，是通过层层对比，单单对比来进行的，对于我们的前端性能来说，很明显是不可以这样实现的。")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://img-blog.csdnimg.cn/20201216223507691.png#pic_center",alt:"在这里插入图片描述"}})]),t._v(" "),v("p",[t._v("前端的虚拟DOM对比")])])]),t._v(" "),v("p",[v("strong",[t._v("所以，前端的diff算法是通过以下步骤来实现的")])]),t._v(" "),v("blockquote",[v("p",[t._v("步骤一：用JS对象模拟DOM树 步骤二：比较两棵虚拟DOM树的差异 步骤三：把差异应用到真正的DOM树上")])]),t._v(" "),v("p",[v("strong",[t._v("同时维护新旧两棵虚拟DOM树，当数据发生改变的时候，开始执行对比")])]),t._v(" "),v("p",[v("strong",[t._v("首先对根元素进行对比，如果根元素发生改变就直接对根元素替换")])]),t._v(" "),v("p",[v("strong",[t._v("如果根元素没有发生改变的话，再对下一层元素进行对比，如果对比发现元素发生删除，就执行删除，发现元素被替换就执行替换，发现添加了新的元素就执行添加")])]),t._v(" "),v("p",[v("strong",[t._v("对比的同时，会通过key值来判断元素是否发生改变，判断元素是仅仅位置发生改变还是需要整个替换或删除")])]),t._v(" "),v("p",[v("strong",[t._v("如果不是元素发生改变的话，再对内容进行对比，如果是内容发生改变的话，就直接修改内容")])]),t._v(" "),v("p",[v("strong",[t._v("其实就是进行逐层对比，再通过不同的对比来判断执行不同的操作")])])])}),[],!1,null,null,null);s.default=r.exports}}]);