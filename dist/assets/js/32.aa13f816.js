(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{524:function(t,s,a){"use strict";a.r(s);var n=a(1),e=Object(n.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"【简答题】一、请说出下列最终的执行结果-并解释为什么。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#【简答题】一、请说出下列最终的执行结果-并解释为什么。"}},[t._v("#")]),t._v(" 【简答题】一、请说出下列最终的执行结果，并解释为什么。")]),t._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" a "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" i "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  a"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("i"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    console"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("i"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\na"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("6")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br"),a("span",{staticClass:"line-number"},[t._v("7")]),a("br")])]),a("p",[t._v("运行结果：")]),t._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("10\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("p",[t._v("原因：")]),t._v(" "),a("p",[t._v("代码中存在两个全局变量，数组a与循环变量i（变量i是var声明的，因此在全局范围内都有效）。每一次循环，新的i值都会覆盖旧值（循环内被赋给数组a的函数内部的console.log(i)，里面的i指向的就是全局的i）。这就导致最后输出的是最后一轮的i的值。\n而使用let声明的变量仅在块级作用域内有效，则不会出现这个问题。")]),t._v(" "),a("h2",{attrs:{id:"【简答题】二、请说出下列最终的执行结果-并解释为什么。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#【简答题】二、请说出下列最终的执行结果-并解释为什么。"}},[t._v("#")]),t._v(" 【简答题】二、请说出下列最终的执行结果，并解释为什么。")]),t._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" tmp "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("123")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  console"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("tmp"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" tmp\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br")])]),a("p",[t._v("运行失败：")]),t._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("ReferenceError: Cannot access 'tmp' before initialization\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("p",[t._v("原因：")]),t._v(" "),a("ol",[a("li",[t._v("代码中的 let tmp 创建过程会提升到block（块级作用域）第一行。因此 console.log(tmp) 中的 tmp 指的是下面的tmp，而不是全局的tmp。")]),t._v(" "),a("li",[t._v("执行 console.log(tmp) 时，tmp 的初始化还没有被提升，也就是出现了暂时死区，因此不能用。")])]),t._v(" "),a("h2",{attrs:{id:"【简答题】三、结合es6新语法-用最简单的方法找出数组中的最小值。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#【简答题】三、结合es6新语法-用最简单的方法找出数组中的最小值。"}},[t._v("#")]),t._v(" 【简答题】三、结合ES6新语法，用最简单的方法找出数组中的最小值。")]),t._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" arr "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("12")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("34")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("32")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("89")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("4")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("p",[t._v("解答：")]),t._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("console.log(Math.min(...arr))\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("h2",{attrs:{id:"【简答题】四、请详细说明var-let-const三种声明变量的方式之间的具体差别。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#【简答题】四、请详细说明var-let-const三种声明变量的方式之间的具体差别。"}},[t._v("#")]),t._v(" 【简答题】四、请详细说明var，let，const三种声明变量的方式之间的具体差别。")]),t._v(" "),a("ol",[a("li",[t._v("var定义的变量，没有块的概念，可以跨块访问, 不能跨函数访问。")]),t._v(" "),a("li",[t._v("let定义的变量，只能在块作用域里访问，不能跨块访问，也不能跨函数访问。")]),t._v(" "),a("li",[t._v("const用来定义常量，使用时必须初始化(即必须赋值)，只能在块作用域里访问，而且不能修改。")])]),t._v(" "),a("ul",[a("li",[t._v("var、let与const的区别\n"),a("ul",[a("li",[t._v("第一点不同是 let 与 const 是块作用域，即其在整个大括号 {} 之内可见。")]),t._v(" "),a("li",[t._v("第二点不同是 let 与 const 在变量声明之前就访问变量的话，会直接提示 ReferenceError，而不像 var 那样使用默认值 undefined。")]),t._v(" "),a("li",[t._v("第三点不同是 let 与 const 存在暂时性死区，只要块级作用域有 let 或者 const 命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。在 let/const 变量被赋值(LexicalBinding)以前是不可以读写的。")]),t._v(" "),a("li",[t._v("第四点不同是 let 与 const 不允许重复声明。。")]),t._v(" "),a("li",[t._v("第五点不同是 const 定义的变量的引用不能被更改。")])])])]),t._v(" "),a("p",[a("strong",[t._v("但是值得注意的是：var, let/const 都有变量提升。")])]),t._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[t._v("console"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("foo"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("      "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Uncaught ReferenceError: Cannot access 'foo' before initialization")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" foo "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("123")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br")])]),a("p",[t._v("发生了引用错误，但是这是因为let定义的变量不存在提升导致的么？")]),t._v(" "),a("p",[t._v("作为对照，我们直接运行下面的代码，看看会出现什么错误：")]),t._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[t._v("console"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("foo"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("      "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//  Uncaught ReferenceError: foo is not defined")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("p",[t._v("错误原因：foo没有定义。")]),t._v(" "),a("p",[t._v("如果说let foo不存在变量提升，那么在运行")]),t._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[t._v("console"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("foo"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" foo "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("123")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br")])]),a("p",[t._v("也应该报出foo没有定义这个错误的，但是错误却是因为foo没有被初始化，所以不能使用（也就是所谓的暂时死区，也正是由于存在tdz死区的限制，所以在块内使用let const声明前访问，会报错）。")]),t._v(" "),a("p",[a("strong",[t._v("其实 let 和 const 定义的变量都会被提升，但是不会被初始化，不能被引用")]),t._v("，不会像var定义的变量那样，初始值为undefined。")]),t._v(" "),a("p",[t._v("为什么let和const定义的变量不会被初始化呢？主要是因为const。const，顾名思义：常量，const的引用不应被改变。如果编译器把const初始化为undefined，之后，又让它等于我们定义的那个值，就改变了const的引用。因此，委员会决定let和const虽然也会发生变量提升，但是没有任何初始值。")]),t._v(" "),a("p",[t._v("对于以上变量提升的问题，如果还有疑问，可以看这篇"),a("a",{attrs:{href:"https://blog.csdn.net/Napoleonxxx/article/details/104219598",target:"_blank",rel:"noopener noreferrer"}},[t._v("let/const 的变量提升与暂时性死区"),a("OutboundLink")],1),t._v("，以及这篇"),a("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/28140450?utm_medium=social",target:"_blank",rel:"noopener noreferrer"}},[t._v("我用了两个月的时间才理解 let"),a("OutboundLink")],1)]),t._v(" "),a("h2",{attrs:{id:"【简答题】五、请说出下列代码最终输出的结果-并解释为什么。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#【简答题】五、请说出下列代码最终输出的结果-并解释为什么。"}},[t._v("#")]),t._v(" 【简答题】五、请说出下列代码最终输出的结果，并解释为什么。")]),t._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" a "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" obj "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  a"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("20")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("fn")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("setTimeout")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      console"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("a"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\nobj"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("fn")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br"),a("span",{staticClass:"line-number"},[t._v("7")]),a("br"),a("span",{staticClass:"line-number"},[t._v("8")]),a("br"),a("span",{staticClass:"line-number"},[t._v("9")]),a("br"),a("span",{staticClass:"line-number"},[t._v("10")]),a("br")])]),a("p",[t._v("运行结果：")]),t._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("20\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("p",[t._v("原因：")]),t._v(" "),a("p",[t._v("这道题与this的指向问题有关，首先，通过obj.fn()调用，fn()函数内部的this指向为obj。而setTimeout函数中的箭头函数没有this指向，它会根据外部作用域而定，而这里的this就指向obj对象，因此obj.a的结果就为20。")]),t._v(" "),a("h2",{attrs:{id:"【简答题】六、简述symbol类型的用途。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#【简答题】六、简述symbol类型的用途。"}},[t._v("#")]),t._v(" 【简答题】六、简述symbol类型的用途。")]),t._v(" "),a("ul",[a("li",[t._v("Symbol的作用就是"),a("strong",[t._v("表示一个独一无二的值")]),t._v("，我们通过Symbol创建的每一个值都是独一无二的，永远不会重复。")])]),t._v(" "),a("p",[t._v("考虑到开发过程中的调试，"),a("strong",[t._v("Symbol允许传入一个字符串作为这个值的描述文本")]),t._v("。它除了可以避免对象属性名重复产生的问题，我们还可以借助这种类型的特点模拟对象的私有成员。")]),t._v(" "),a("ul",[a("li",[t._v("补充")])]),t._v(" "),a("ol",[a("li",[t._v("通过Symbol创建的值一定是一个唯一的值，不管传入的描述文本是否相同。")]),t._v(" "),a("li",[t._v("使用Symbol类型提供的静态方法for()在全局去复用一个相同的Symbol值。这个方法内部维护了一个全局的注册表，为字符串和Symbol值提供了一一对应的关系。如果传入的不是字符串，方法内部会将其自动转化为字符串。")]),t._v(" "),a("li",[t._v("除了定义自己使用的Symbol值以外，ES2015还提供了11个内置Symbol值，指向语言内部使用的方法。")]),t._v(" "),a("li",[t._v("Object对象里面的getOwnPropertySymbols()方法可以获取到Symbol类型的属性名。")])]),t._v(" "),a("h2",{attrs:{id:"【简答题】七、说说什么是浅拷贝、什么是深拷贝"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#【简答题】七、说说什么是浅拷贝、什么是深拷贝"}},[t._v("#")]),t._v(" 【简答题】七、说说什么是浅拷贝、什么是深拷贝？")]),t._v(" "),a("ul",[a("li",[t._v("浅拷贝\n"),a("ul",[a("li",[t._v("浅拷贝只拷贝一层，更深层对象级别只拷贝引用（只是拷贝了地址）")]),t._v(" "),a("li",[t._v("由于是浅复制，所以引用类型只是复制了内存地址，修改其中一个对象的子属性后，引用这个地址的值都会被修改")]),t._v(" "),a("li",[t._v("对于浅拷贝的实现，最基础的循环赋值不再提，除此之外：\n"),a("ul",[a("li",[a("strong",[t._v("Object.assign(target,...sources) ES6新增方法实现的就是浅拷贝")])]),t._v(" "),a("li",[a("strong",[t._v("ES6扩展运算符 ... 的方式解构实现浅拷贝")])])])])])]),t._v(" "),a("li",[t._v("深拷贝\n"),a("ul",[a("li",[t._v("深拷贝拷贝多层，每一级别的数据都会拷贝 (内部开辟了新的内存空间进行存储)")]),t._v(" "),a("li",[t._v("其实深拷贝可以拆分成 2 步，浅拷贝 + 递归，所以循环赋值配合递归也能实现，除此之外：\n"),a("ul",[a("li",[a("strong",[t._v("For...in遍历并递归。")]),t._v("（注意：如果使用Symbol值作为对象的属性名，这个属性通过for...in是无法拿到的，而且通过Objec.keys()方法也是获取不到Symbol属性名的，如果通过JSON.stringfy()去序列化对象为一个JSON字符串的话，Symbol属性也会被忽略掉。）")]),t._v(" "),a("li",[t._v("因此我们还可以使用"),a("strong",[t._v("解构配合Object对象里面getOwnPropertySymbols()方法或者ES6的Reflect.ownKeys(obj)递归")]),t._v("实现深拷贝。")])])])])])]),t._v(" "),a("h2",{attrs:{id:"【简答题】八、请简述typescript与javascript之间的关系。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#【简答题】八、请简述typescript与javascript之间的关系。"}},[t._v("#")]),t._v(" 【简答题】八、请简述TypeScript与JavaScript之间的关系。")]),t._v(" "),a("ol",[a("li",[t._v("TypeScript是JavaScript的一个超集，包含了JavaScript的所有元素，提供了类型系统和对ES6+的支持。")])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://img-blog.csdnimg.cn/20201008154915567.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1MTQ5MjU2,size_16,color_FFFFFF,t_70#pic_center",alt:"在这里插入图片描述"}})]),t._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[t._v("TypeScript 可以使用 JavaScript 中的所有代码和编码概念，TypeScript 是为了使 JavaScript 的开发变得更加容易而创建的。")]),t._v(" "),a("li",[t._v("TypeScript是JavaScript的类型超集，他可以编译成纯JavaScript。编译出来的JavaScript可以运行在任何浏览器上，TypeScript编译工具可以运行在任何服务器和任何系统上。")])]),t._v(" "),a("h2",{attrs:{id:"【简答题】九、请谈谈你所认为的typescript优缺点。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#【简答题】九、请谈谈你所认为的typescript优缺点。"}},[t._v("#")]),t._v(" 【简答题】九、请谈谈你所认为的TypeScript优缺点。")]),t._v(" "),a("ul",[a("li",[t._v("优点：")])]),t._v(" "),a("p",[a("strong",[t._v("1.TypeScript非常包容")]),t._v("\nTypeScript是JavaScript的超集，.js文件直接重命名为.ts即可。即使不显式的定义类型也能够自动做出类型推断。可以定义从简单到复杂的几乎一切的类型。即使TypeScript编译报错，也可以生成JavaScript文件。TypeScript是开源的。")]),t._v(" "),a("p",[a("strong",[t._v("2.更好的协作")]),t._v("\n类型安全是一种在编码期间检测错误的功能，而不是在编译项目时检测错误，这为开发团队创建了一个更高效的编码和调试过程。")]),t._v(" "),a("p",[a("strong",[t._v("3.更强的生产力")]),t._v("\n干净的 ECMAScript 6 代码，自动完成和动态输入等因素有助于提高开发人员的工作效率。增强了编辑器和IDE的功能，包括代码补全、接口提示、跳转到定义、重构等。")]),t._v(" "),a("ul",[a("li",[t._v("缺点：")])]),t._v(" "),a("p",[a("strong",[t._v("1.增加学习成本")]),t._v("\n语言本身多了很多概念，例如接口(Interfaces)、泛型(Generics)、类(Classer)、枚举类型(Enums)等非前端概念，学习成本增加。")]),t._v(" "),a("p",[a("strong",[t._v("2.项目初期会增加一些成本")]),t._v("\n毕竟要多写一些类型的定义，开发成本的增加是不可避免的。不过对于一些需要长期维护的项目，TypeScript能够减少其维护成本。")]),t._v(" "),a("p",[a("strong",[t._v("3.可能和一些库结合的不是很完美")]),t._v("\n在实际开发中需要使用到第三方npm模块，而这些模块不一定是通过TypeScript编写的，所以它提供的成员就不会有强类型体验。但是目前越来越多的模块已经在内部集成类型声明文件了。")]),t._v(" "),a("h2",{attrs:{id:"【简答题】十、描述引用计数的工作原理和优缺点。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#【简答题】十、描述引用计数的工作原理和优缺点。"}},[t._v("#")]),t._v(" 【简答题】十、描述引用计数的工作原理和优缺点。")]),t._v(" "),a("p",[a("strong",[t._v("引用计数算法的工作原理")])]),t._v(" "),a("ul",[a("li",[t._v("核心思想：设置引用数，判断当前引用数是否为0")]),t._v(" "),a("li",[t._v("引用计数器")]),t._v(" "),a("li",[t._v("引用关系改变时修改引用数字")]),t._v(" "),a("li",[t._v("引用数字为0时立即回收")])]),t._v(" "),a("p",[a("strong",[t._v("引用计数算法的优缺点")])]),t._v(" "),a("ul",[a("li",[t._v("引用计数算法优点\n"),a("ul",[a("li",[t._v("发现垃圾时立即回收")]),t._v(" "),a("li",[t._v("最大限度减少程序暂停")])])]),t._v(" "),a("li",[t._v("引用计数算法缺点\n"),a("ul",[a("li",[t._v("无法回收循环引用的对象")]),t._v(" "),a("li",[t._v("时间开销大（资源消耗较大）")])])])]),t._v(" "),a("h2",{attrs:{id:"【简答题】十一、描述标记整理算法的工作流程。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#【简答题】十一、描述标记整理算法的工作流程。"}},[t._v("#")]),t._v(" 【简答题】十一、描述标记整理算法的工作流程。")]),t._v(" "),a("p",[a("strong",[t._v("标记整理算法的工作流程")])]),t._v(" "),a("ul",[a("li",[t._v("核心思想：分标记和清除两个阶段完成")]),t._v(" "),a("li",[t._v("遍历所有对象找标记活动对象（可达对象）")]),t._v(" "),a("li",[t._v("清除阶段会先执行整理，移动对象位置")]),t._v(" "),a("li",[t._v("遍历所有对象清除没有标记对象")]),t._v(" "),a("li",[t._v("回收相应的空间到空闲列表（连续）")])]),t._v(" "),a("h2",{attrs:{id:"【简答题】十二、描述v8中新生代存储区垃圾回收的流程。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#【简答题】十二、描述v8中新生代存储区垃圾回收的流程。"}},[t._v("#")]),t._v(" 【简答题】十二、描述V8中新生代存储区垃圾回收的流程。")]),t._v(" "),a("p",[a("strong",[t._v("新生代对象回收实现")])]),t._v(" "),a("ol",[a("li",[t._v("回收过程采用复制算法+标记整理")]),t._v(" "),a("li",[t._v("新生代内存区分为两个等大小空间")]),t._v(" "),a("li",[t._v("使用空间From，空闲空间To")]),t._v(" "),a("li",[t._v("活动对象存储于From空间")]),t._v(" "),a("li",[t._v("标记整理后将活动对象拷贝至To")]),t._v(" "),a("li",[t._v("From与To交换空间完成释放")])]),t._v(" "),a("p",[a("strong",[t._v("回收细节说明")])]),t._v(" "),a("ul",[a("li",[t._v("拷贝过程中可能会出现晋升")]),t._v(" "),a("li",[t._v("晋升就是将新生代对象移动至老生代")]),t._v(" "),a("li",[t._v("一轮 GC 还存活的新生代需要晋升")]),t._v(" "),a("li",[t._v("To 空间的使用率超过25%需要晋升")])]),t._v(" "),a("h2",{attrs:{id:"【简答题】十三、描述增量标记算法在何时使用及工作原理。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#【简答题】十三、描述增量标记算法在何时使用及工作原理。"}},[t._v("#")]),t._v(" 【简答题】十三、描述增量标记算法在何时使用及工作原理。")]),t._v(" "),a("p",[a("strong",[t._v("增量标记算法在何时使用")])]),t._v(" "),a("ul",[a("li",[t._v("由于 JavaScript 是运行在主线程之上的，一旦执行垃圾回收算法，都需要将正在执行的 JavaScript 脚本暂停下来，待垃圾回收完毕后再恢复脚本执行，称全停顿（Stop-The-World）")]),t._v(" "),a("li",[t._v("在 V8 新生代的垃圾回收中，因其空间较小，且存活对象较少，所以全停顿的影响不大")]),t._v(" "),a("li",[t._v("在 V8 老年代的垃圾回收中，为了降低老生代的垃圾回收而造成的卡顿，使用增量标记算法")])]),t._v(" "),a("p",[a("strong",[t._v("增量标记算法的工作原理")])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://img-blog.csdnimg.cn/20201009162641520.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1MTQ5MjU2,size_16,color_FFFFFF,t_70#pic_center",alt:"在这里插入图片描述"}})]),t._v(" "),a("ul",[a("li",[t._v("V8 将标记过程分为一个个的子标记过程")]),t._v(" "),a("li",[t._v("让垃圾回收标记和 JavaScript 应用逻辑交替进行，直到标记阶段完成")]),t._v(" "),a("li",[t._v("这些小的垃圾回收任务执行时间比较短，可以最大限度减少程序暂停时间")]),t._v(" "),a("li",[t._v("标记完后执行清除，程序继续执行")])])])}),[],!1,null,null,null);s.default=e.exports}}]);