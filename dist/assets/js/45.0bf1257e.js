(window.webpackJsonp=window.webpackJsonp||[]).push([[45],{535:function(e,t,a){"use strict";a.r(t);var v=a(1),_=Object(v.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h2",{attrs:{id:"说一下在webpack中的loader和plugin的不同"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#说一下在webpack中的loader和plugin的不同"}},[e._v("#")]),e._v(" 说一下在webpack中的loader和plugin的不同")]),e._v(" "),a("h3",{attrs:{id:"解题思路"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#解题思路"}},[e._v("#")]),e._v(" 解题思路：")]),e._v(" "),a("p",[a("strong",[e._v("不同的作用")])]),e._v(" "),a("ul",[a("li",[a("strong",[e._v("Loader")]),e._v('直译为"加载器"。Webpack将一切文件视为模块，但是webpack原生是只能解析js文件，如果想将其他文件也打包的话，就会用到'),a("code",[e._v("loader")]),e._v("。 所以Loader的作用是让webpack拥有了加载和解析 "),a("em",[e._v("非JavaScript文件")]),e._v(" 的能力。")]),e._v(" "),a("li",[a("strong",[e._v("Plugin")]),e._v('直译为"插件"。Plugin可以扩展webpack的功能，让webpack具有更多的灵活性。 在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。')])]),e._v(" "),a("p",[a("strong",[e._v("不同的用法")])]),e._v(" "),a("ul",[a("li",[a("strong",[e._v("Loader")]),e._v("在"),a("code",[e._v("module.rules")]),e._v("中配置，也就是说他作为模块的解析规则而存在。 类型为数组，每一项都是一个"),a("code",[e._v("Object")]),e._v("，里面描述了对于什么类型的文件（"),a("code",[e._v("test")]),e._v("），使用什么加载("),a("code",[e._v("loader")]),e._v(")和使用的参数（"),a("code",[e._v("options")]),e._v("）")]),e._v(" "),a("li",[a("strong",[e._v("Plugin")]),e._v("在"),a("code",[e._v("plugins")]),e._v("中单独配置。 类型为数组，每一项是一个"),a("code",[e._v("plugin")]),e._v("的实例，参数都通过构造函数传入。")])])])}),[],!1,null,null,null);t.default=_.exports}}]);